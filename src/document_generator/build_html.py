"""
Final HTML document builder
"""

import re
import sys
from pathlib import Path
import markdown

sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.json_io import load_text, save_text


HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }}
        
        .container {{
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        
        h1 {{
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }}
        
        h2 {{
            color: #34495e;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-top: 10px;
            border-top: 2px solid #ecf0f1;
        }}
        
        h3 {{
            color: #7f8c8d;
            margin-top: 20px;
            margin-bottom: 10px;
        }}
        
        .timestamp {{
            display: inline-block;
            background-color: #3498db;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: 'Courier New', monospace;
            margin-bottom: 10px;
        }}
        
        .section {{
            margin-bottom: 40px;
        }}
        
        .gif-container {{
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }}
        
        .gif-container img {{
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }}
        
        ul, ol {{
            margin-left: 30px;
            margin-bottom: 15px;
        }}
        
        li {{
            margin-bottom: 8px;
        }}
        
        code {{
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }}
        
        pre {{
            background-color: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }}
        
        pre code {{
            background-color: transparent;
            padding: 0;
            color: inherit;
        }}
        
        .summary {{
            background-color: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }}
        
        .footer {{
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ecf0f1;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9em;
        }}
        
        @media (max-width: 768px) {{
            .container {{
                padding: 20px;
            }}
            
            body {{
                padding: 10px;
            }}
        }}
    </style>
</head>
<body>
    <div class="container">
        {content}
        <div class="footer">
            <p>Generated by Instruction Video to Teaching Document Generator</p>
        </div>
    </div>
</body>
</html>
"""


def inject_gifs_into_markdown(markdown_content, relevant_gifs, grouped_data):
    """
    Replace {GIF:id} placeholders in the markdown with GIF HTML blocks.

    Args:
        markdown_content: str - original markdown with {GIF:0} style placeholders
        relevant_gifs: Dict[group_id -> Path] mapping each group to GIF file path
        grouped_data: List of groups (used for fallback timestamp injection)

    Returns:
        str: Markdown with GIF embeds
    """
    import re

    # Pattern: {GIF:0}, {GIF:12}, etc. (with colon, not underscore)
    gif_pattern = r'\{GIF:(\d+)\}'

    def replace_match(match):
        group_id = int(match.group(1))

        # If this group has a GIF â†’ embed it
        if group_id in relevant_gifs:
            gif_path = relevant_gifs[group_id]
            gif_filename = gif_path.name  # e.g., clip_3.gif

            return (
                '\n<div class="gif-container">\n'
                f'  <img src="gifs/{gif_filename}" alt="Section {group_id + 1} Demonstration">\n'
                '</div>\n'
            )

        # If GIF doesn't exist or not relevant, remove placeholder
        return ""

    # Replace all {GIF:X} occurrences
    modified_content = re.sub(gif_pattern, replace_match, markdown_content)
    
    # Strategy 2: Fallback - if no placeholders found, inject GIFs after timestamps
    if '{GIF:' not in markdown_content:
        lines = modified_content.split('\n')
        output_lines = []
        
        # Build timestamp to group mapping
        timestamp_to_group = {}
        for group in grouped_data:
            start = group['group_start_time']
            timestamp_to_group[start] = group['group_id']
        
        # Track which GIFs we've used
        used_gifs = set()
        
        for i, line in enumerate(lines):
            output_lines.append(line)
            
            # Look for timestamp patterns [H:MM:SS - H:MM:SS]
            timestamp_pattern = r'\[(\d+:\d+:\d+)\s*-\s*(\d+:\d+:\d+)\]'
            match = re.search(timestamp_pattern, line)
            
            if match:
                start_time = match.group(1)
                
                # Find matching group
                for group in grouped_data:
                    if group['group_start_time'] == start_time:
                        group_id = group['group_id']
                        
                        if group_id in relevant_gifs and group_id not in used_gifs:
                            gif_path = relevant_gifs[group_id]
                            gif_filename = gif_path.name
                            
                            # Inject GIF reference
                            output_lines.append('')
                            output_lines.append('<div class="gif-container">')
                            output_lines.append(f'  <img src="gifs/{gif_filename}" alt="Section {group_id + 1}">')
                            output_lines.append('</div>')
                            output_lines.append('')
                            
                            used_gifs.add(group_id)
                        break
        
        modified_content = '\n'.join(output_lines)
    
    return modified_content


def build_final_html(document_path, relevant_gifs, grouped_data, output_dir, logger=None):
    """
    Build final HTML document with embedded GIFs
    
    Args:
        document_path: Path to markdown document
        relevant_gifs: Dict mapping group_id to GIF path
        grouped_data: List of grouped segments
        output_dir: Output directory
        logger: Logger instance
        
    Returns:
        Path: Path to generated HTML file
    """
    if logger:
        logger.info("Building final HTML document")
    
    # Load markdown content
    markdown_content = load_text(document_path)
    
    # Inject GIFs
    modified_markdown = inject_gifs_into_markdown(markdown_content, relevant_gifs, grouped_data)
    
    # Convert markdown to HTML
    html_content = markdown.markdown(
        modified_markdown,
        extensions=['fenced_code', 'codehilite', 'tables']
    )
    
    # Extract title (first h1)
    title_match = re.search(r'<h1>(.*?)</h1>', html_content)
    title = title_match.group(1) if title_match else "Teaching Document"
    
    # Build final HTML
    final_html = HTML_TEMPLATE.format(
        title=title,
        content=html_content
    )
    
    # Save HTML file
    html_path = Path(output_dir) / 'index.html'
    save_text(final_html, html_path)
    
    if logger:
        logger.info(f"HTML document saved to: {html_path}")
        logger.info(f"Embedded {len(relevant_gifs)} GIFs")
    
    return html_path


def create_standalone_html(grouped_data, relevant_gifs, output_dir, title="Teaching Notes"):
    """
    Create HTML directly from grouped data (alternative approach)
    
    Args:
        grouped_data: List of grouped segments
        relevant_gifs: Dict mapping group_id to GIF path
        output_dir: Output directory
        title: Document title
        
    Returns:
        Path: Path to HTML file
    """
    sections_html = []
    
    sections_html.append(f'<h1>{title}</h1>')
    
    for group in grouped_data:
        group_id = group['group_id']
        start_time = group['group_start_time']
        end_time = group['group_end_time']
        summary = group['group_summary']
        
        sections_html.append('<div class="section">')
        sections_html.append(f'<h2>Section {group_id + 1}</h2>')
        sections_html.append(f'<span class="timestamp">{start_time} - {end_time}</span>')
        
        # Add GIF if available
        if group_id in relevant_gifs:
            gif_path = relevant_gifs[group_id]
            gif_filename = gif_path.name
            sections_html.append('<div class="gif-container">')
            sections_html.append(f'  <img src="gifs/{gif_filename}" alt="Section {group_id + 1}">')
            sections_html.append('</div>')
        
        # Add summary
        sections_html.append('<div class="summary">')
        sections_html.append(f'<p>{summary}</p>')
        sections_html.append('</div>')
        
        sections_html.append('</div>')
    
    content = '\n'.join(sections_html)
    
    final_html = HTML_TEMPLATE.format(
        title=title,
        content=content
    )
    
    html_path = Path(output_dir) / 'index.html'
    save_text(final_html, html_path)
    
    return html_path